var bootState = {
  create: function(){
    Phaser.Canvas.setImageRenderingCrisp(game.canvas);

    // Set world bounds
    game.world.setBounds(0, 0, 160, 144);
    game.camera.roundPx = false;

    // Scale the game up
    game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
    game.scale.minWidth = 320;
    game.scale.minHeight = 288;
    game.scale.maxWidth = 320;
    game.scale.maxHeight = 288;
    game.scale.refresh();

    // Deal with antialiasing
    game.stage.smoothed = false;
    game.renderer.renderSession.roundPixels = true;

    // Call the next state
    game.state.start('load');
  }
};
var loadState = {
  preload: function(){
    // Neatfun logo
  	// game.load.image('neatfun', 'assets/img/neatfun.gif');

    // Title image
  	game.load.image('title', 'assets/img/title.gif');

    // Sound effects
  	game.load.audio('sfx', ['assets/sfx/sfx.mp3']);

    // Music
    game.load.audio('music', ['assets/music/score.mp3']);

  	// Player sprite
  	game.load.spritesheet('player', 'assets/img/player.gif', 24, 24, 10);

    // PC icon sprite
  	game.load.spritesheet('pcIcon', 'assets/img/pcIcon.gif', 9, 9, 1);

    // Heart sprite
  	game.load.spritesheet('heart', 'assets/img/heart.gif', 9, 9, 2);

    // PC sprite
  	game.load.spritesheet('pc', 'assets/img/pc.gif', 16, 24, 8);

    // Smoke sprite
    game.load.spritesheet('smoke', 'assets/img/smoke.gif', 16, 16, 4);

    // Powerup sprites
    game.load.spritesheet('coffee', 'assets/img/coffee.gif', 16, 16, 2);
    game.load.spritesheet('disk', 'assets/img/disk.gif', 16, 16, 1);
    game.load.spritesheet('comic', 'assets/img/comic.gif', 16, 16, 1);

    // Transparent bounds
    game.load.spritesheet('playerTransparent', 'assets/img/playerTransparent.gif', 25, 25, 1);
    game.load.spritesheet('wallTransparent', 'assets/img/wallTransparent.gif', 160, 12, 1);
    game.load.spritesheet('deskTransparent', 'assets/img/deskTransparent.gif', 24, 24, 1);
    game.load.spritesheet('pcTransparent', 'assets/img/pcTransparent.gif', 16, 16, 1);

    // Tile maps
    game.load.tilemap('map', 'assets/json/map.json', null, Phaser.Tilemap.TILED_JSON);
    game.load.image('floor', 'assets/img/floor.gif');
    game.load.image('desk', 'assets/img/desk.gif');

    // Font
    game.load.bitmapFont('ITBit', 'assets/type/ITBit.png', 'assets/type/ITBit.fnt');

    // Button
    game.load.image('button', 'assets/img/button.gif');

    // Pause
    game.load.image('pause', 'assets/img/pause.gif');
  },
  create: function(){
    // Call the next state
    game.state.start('title');
  }
};

var neatfunState = {
  create: function(){
    game.add.sprite(0, 0, 'neatfun');

    // Call the next state
    setTimeout(function(){
      game.state.start('title');
    }, 1000);
  }
};
var titleState  = {
  create: function(){
    // Title image
    title = game.add.sprite(0, 0, 'title');

    // Start the game when a key is pressed
    game.input.keyboard.onDownCallback = function() {
      game.input.keyboard.onDownCallback = null;
      game.state.start('level01', true);
    }
  }
};
// Global variables
breakDelay = 2;
brokenPCTimeout = 10;
dropDelay = 1;
poweredUp = false;
powerupTimeout = 10;
runSpeed = 48;
volumeLevel = .5;

var level01State = {
  create: function(){
    // Reset the elapsed time
    game.time.reset();

    // Initial values
    againstDesk = false;
    breakTime = 0;
    brokenPCs = [];
    brokenPCTimers = [];
    direction = 'down';
    fixedCount = 0;
    maxBroken = 1;
    playerLives = 3;
    playerScore = 0;
    score = 0;

    // Define controls
  	controls = game.input.keyboard.createCursorKeys();
    fixKey = game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR);
    pauseKey = game.input.keyboard.addKey(Phaser.Keyboard.ESC);

    // Set background color
    game.stage.backgroundColor = '#9bbc0f';

    // Create tile map
    map = game.add.tilemap('map');
    map.addTilesetImage('floor', 'floor');
    map.addTilesetImage('desk', 'desk');
    map.addTilesetImage('pc', 'pc');

    // Create floor layer
    floor = map.createLayer('floorLayer');

    // Create desk layer
    desk = map.createLayer('deskLayer');

    // Create a group for powerups
    powerups = game.add.group();
    powerups.enableBody = true;

    // Create player
    var initialX = game.world.width / 2 - 12;
    var initialY = game.world.height - 32

    player = game.add.sprite(initialX, initialY, 'player');
    game.physics.enable(player);
    player.body.collideWorldBounds = true;
    player.animations.add('walkDown', [1, 2]);
  	player.animations.add('walkUp', [4, 5]);
    player.animations.add('walkLeft', [7, 6]);
    player.animations.add('walkRight', [9, 8]);

    // Add a child sprite to the player to detect PC collision
    playerBounds = player.addChild(game.make.sprite(-1, -1, 'playerTransparent'));
    game.physics.enable(playerBounds)

    // Create collision-objects
    wallBounds = game.add.group();
    createBounds('wall', 'wallBounds', wallBounds);

    deskBounds = game.add.group();
    createBounds('desk', 'deskBounds', deskBounds);

    pcBounds = game.add.group();
    createBounds('pc', 'pcBounds', pcBounds);

    // Make bounds immovable
    wallBounds.forEach(function(wall) {
      wall.body.immovable = true;
    });

    deskBounds.forEach(function(desk) {
      desk.body.immovable = true;
    });

    pcBounds.forEach(function(pc) {
      pc.body.immovable = true;
    });

    // Create PC sprite layer
    pcSprites = game.add.group();
    createSprites(pcSprites, 'pcSprite', 'pcSprites');

    pcSprites.forEach(function(pcSprite) {
      pcSprite.animations.add('pcFunction', [0, 0, 0, 1, 2, 3, 4, 5, 5, 5]);
      pcSprite.animations.add('pcBreak', [6, 7]);
      pcSprite.animations.play('pcFunction', 4, true);
    });

    // Assign an ID to each PC sprite
    var idNum = 0;

    pcSprites.forEach(function(pc) {
      pc.idNum = idNum;
      idNum++;
    });

    // Create a group for smoke sprites
    smokeSprites = game.add.group();

    // Create sfx track
    sfx = game.add.audio('sfx');
  	sfx.addMarker('break', 0, .32);
    sfx.addMarker('drop', .32, .423);
    sfx.addMarker('bump', .743, .262);
    sfx.addMarker('fix', 1.005, .270);
    sfx.addMarker('interact', 1.275, .115);
    sfx.addMarker('powerup', 1.391, .446);
    sfx.addMarker('die', 1.837, .316)

    // Create music track
    music = game.add.audio('music');
    music.addMarker('loop', 0, 64, .5, true);
    music.play('loop');

    // Interact with PCs
    fixKey.onDown.add(function() {
      if(direction === 'up') {
        game.physics.arcade.overlap(playerBounds, pcBounds, function(obj1, obj2) {
          // Get the index of the PC that is being
          // interacted with and fix it if it
          // matches the index of the broken PC
          var thisPCIndex = pcBounds.getIndex(obj2);

          if(brokenPCs.indexOf(thisPCIndex) > -1) {
            fixPC(thisPCIndex, 'pass');
          } else {
            sfx.play('interact', 0, volumeLevel);
          }
        });
      }
    });

    // Pause the game
    pauseKey.onDown.add(function() {
      handlePause(false);
    });

    game.onBlur.add(function() {
      handlePause(true)
    });

    // Score/lives UI
    var ui = game.add.graphics(0, 0);
    ui.beginFill(0x0f380f);
    ui.drawRect(0, 0, game.world.width, 13);
    window.graphics = ui;

    // Score
    score = game.add.bitmapText(2, 0, 'ITBit', null, 16);

    // Fixed count
    fixedIcon = game.add.sprite(game.world.width / 2 - 6, 2, 'pcIcon');
    fixedIcon.anchor.x = .5;
    fixedText = game.add.bitmapText(game.world.width / 2 + 6, 0, 'ITBit', null, 16);
    fixedText.anchor.x = .5;

    updateScore();

    // Lives
    hearts = game.add.group();

    for(var i = 0; i < playerLives; i++) {
      var x = game.world.width - (11 * (playerLives - i));

      var heartSprite = hearts.create(x, 2, 'heart');
    }
  },
  update: function(){
    // Reset player’s velocity
  	player.body.velocity.x = 0;
    player.body.velocity.y = 0;

    // Set up desk collisions
    game.physics.arcade.collide(player, wallBounds);
    game.physics.arcade.collide(player, deskBounds);

    // Set up powerup collisions
    game.physics.arcade.collide(player, powerups, function(obj1, obj2) {
      obj2.destroy();
      sfx.play('powerup', 0, volumeLevel);

      applyPowerup(obj2.key);
    });

    // Move left
    if(controls.left.isDown) {
  		player.body.velocity.x = -runSpeed;
  		player.animations.play('walkLeft', 5, true);
  		direction = 'left';
    }

    // Move right
    else if(controls.right.isDown) {
  		player.body.velocity.x = runSpeed;
  		player.animations.play('walkRight', 5, true);
  		direction = 'right';
    }

    // Move up
    else if(controls.up.isDown) {
  		player.body.velocity.y = -runSpeed;
  		player.animations.play('walkUp', 5, true);
  		direction = 'up';
    }

    // Move down
    else if(controls.down.isDown) {
  		player.body.velocity.y = runSpeed;
  		player.animations.play('walkDown', 5, true);
  		direction = 'down';
    }

    if(
        !controls.left.isDown &&
        !controls.right.isDown &&
        !controls.up.isDown &&
        !controls.down.isDown
    ) {
      switch (direction) {
        case 'left':
          player.frame = 6;
          break;

        case 'right':
          player.frame = 8;
          break;

        case 'up':
          player.frame = 3;
          break;

        default:
          player.frame = 0;
      }
    }

    // Randomly break a PC
    if(brokenPCs.length < maxBroken && delayBreak()) {
      // For this, we create an array to make sure
      // that only unique random numbers are generated
      var newBrokenPCs = [];

      for(var i = 0; i < maxBroken; i++) {
        brokenPCIndex = Math.floor(Math.random() * 6);

        if(
            newBrokenPCs.indexOf(brokenPCIndex) < 0 &&
            brokenPCs.length < maxBroken &&
            brokenPCs.indexOf(brokenPCIndex) < 0
          ) {
          newBrokenPCs.push(brokenPCIndex);
          breakPC(brokenPCIndex);
        }
      }
    }
  },
  render: function(){
    // game.debug.body(player);

    // game.debug.body(playerBounds);

    // deskBounds.forEach(function(desk){
    //   game.debug.body(desk);
    // });

    // wallBounds.forEach(function(desk){
    //   game.debug.body(desk);
    // });

    // pcBounds.forEach(function(pc){
    //   game.debug.body(pc);
    // });
  }
};

// Create objects
function findObjectsByType(type, map, layerName) {
  var result = [];

  map.objects[layerName].forEach(function(element){
    if(element.properties.type === type) {
      result.push(element);
    }
  });

  return result;
}

// Reusable function to create object sprites
function createFromTiledObject(element, group) {
  var sprite = group.create(element.x, element.y, element.properties.sprite);

  Object.keys(element.properties).forEach(function(key){
    sprite[key] = element.properties[key];
  });
}

// Create bounding objects from tilemap
function createBounds(type, layer, group) {
  group.enableBody = true;

  var result = findObjectsByType(type, map, layer);

  result.forEach(function(element){
    this.createFromTiledObject(element, group);
  });
}

// Create sprite objects from tilemap
function createSprites(group, type, layerName) {
  var result = findObjectsByType(type, map, layerName);

  result.forEach(function(element){
    this.createFromTiledObject(element, group);
  });
}

// Delay PC breaking
function delayBreak() {
	if(game.time.totalElapsedSeconds() > breakTime + breakDelay) {
		breakTime = game.time.totalElapsedSeconds();
		return true;
	} else {
		return false;
	}
}

// Break PC
function breakPC(brokenPCIndex) {
  // Push the index to the array of broken PCs
  brokenPCs.push(brokenPCIndex);

  // Add a timeout for the broken PC
  var brokenPCTimer = game.time.events.add(Phaser.Timer.SECOND * brokenPCTimeout, function() {
    // Take away a life
    playerLives -= 1;

    // Update the hearts
    var lastHeart = hearts.children[playerLives];
    lastHeart.frame = 1;

    // Fix the PC
    fixPC(brokenPCIndex, 'fail');

    // Remove the timer
    game.time.events.remove(brokenPCTimer);

    // If the player is out of lives, game over
    if(playerLives < 1) {
      gameOver();
    }
  });

  brokenPCTimers.push(brokenPCTimer);

  // Set this PC bound object to broken
  pcBounds.children[brokenPCIndex].broken = true;

  // Get the PC sprite with the same index
  pcSprites.forEach(function(pcSprite) {
    if(pcSprite.idNum === brokenPCIndex) {
      // Play the broken PC animation
      pcSprite.animations.play('pcBreak', 4, true);

      // Create a smoke cloud
      smoke = smokeSprites.create(pcSprite.position.x, pcSprite.position.y - 16, 'smoke');
      smoke.animations.add('smolder', [0, 1, 2, 3]);
      smoke.animations.play('smolder', 4, true);

      // Play break sound effect
      sfx.play('break', 0, volumeLevel);
    }
  });
}

// Fix PC
function fixPC(thisPCIndex, type, fixAll) {
  if(fixAll) {
    // Play powerup sound effect
    sfx.play('powerup', 0, volumeLevel);
  } else if(type === 'pass') {
    // Play fix sound effect
    sfx.play('fix', 0, volumeLevel);
  } else if(type === 'fail') {
    // Play fail sound effect
    sfx.play('bump', 0, volumeLevel);
  }

  // Remove this index from the array of broken PCs
  var brokenPCIndex = brokenPCs.indexOf(thisPCIndex);

  // Set this PC bound object to fixed
  pcBounds.children[brokenPCIndex].broken = false;

  // Get the PC sprite with the same index
  pcSprites.forEach(function(pcSprite) {
    if(pcSprite.idNum === thisPCIndex) {
      // Play the broken PC animation
      pcSprite.animations.play('pcFunction', 4, true);
    }
  });

  // Remove the smoke sprite
  if(smokeSprites.children[brokenPCIndex]) {
    smokeSprites.children[brokenPCIndex].destroy();
  }

  // Remove the PC from the array of broken PCs
  // game.time.events.add(500, function() {
    brokenPCs.splice(brokenPCIndex, 1);
  // });

  // Remove the PC’s timeout
  var brokenPCTimer = brokenPCTimers[brokenPCIndex];
  var remainingTime = Math.ceil((brokenPCTimer.tick - game.time.time) / 1000);
  game.time.events.remove(brokenPCTimer);
  brokenPCTimers.splice(brokenPCIndex, 1);

  // Delay the next break
  breakTime = game.time.totalElapsedSeconds();

  // Increase the score if it’s a pass
  if(type === 'pass') {
    fixedCount += 1;
    playerScore += 10 * remainingTime;
    updateScore();
  }

  // Increase the maximum number of broken PCs
  switch (fixedCount) {
    case 10:
      maxBroken = 2;
      break;

    case 25:
      maxBroken = 3;
      break;

    case 50:
      maxBroken = 4;
      break;

    case 100:
      maxBroken = 5;
      break;

    case 250:
      maxBroken = 6;
      break;

    default:
      maxBroken = maxBroken;
  }

  // If the player has fixed 10 PCs, reward them
  // also pass the index of the fixed PC so that
  // we don’t drop the powerup where the player is
  if(fixedCount > 0 && fixedCount % 10 === 0 && powerups.children.length === 0 && !poweredUp) {
    var rand = Math.floor(Math.random() * 3);
    var powerupType;

    switch (rand) {
      case 0:
        powerupType = 'coffee';
        break;

      case 1:
        powerupType = 'disk';
        break;

      case 2:
        powerupType = 'comic';
        break;

      default:
        powerupType = 'coffee';
    }

    game.time.events.add(Phaser.Timer.SECOND * dropDelay, function() {
      dropPowerup(powerupType, thisPCIndex);
    });
  }
}

// Update score
function updateScore() {
  if(playerScore > 999999) {
    playerScore = 999999;
  }

  var formattedScore = playerScore + '';

  while(formattedScore.length < 6) {
    formattedScore = '0' + formattedScore;
  }

  score.setText(formattedScore);
  fixedText.setText(fixedCount);
}

// Drop powerup
function dropPowerup(type, fixedPCIndex) {
  // Possible powerup locations
  powerupLocations = [
    {x: 16, y: 56},
    {x: 72, y: 56},
    {x: 128, y: 56},
    {x: 16, y: 112},
    {x: 72, y: 112},
    {x: 128, y: 112},
  ]

  var rand = Math.floor(Math.random() * 6);

  // Make sure the random position isn’t
  // the same as the fixed pc index
  while (rand === fixedPCIndex) {
    rand = Math.floor(Math.random() * 6);
  }

  var coords = powerupLocations[rand];

  // Create the sprite and drop it
  powerup = powerups.create(coords.x, coords.y, type);
  powerup.animations.add('steam', [0, 1]);
  powerup.animations.play('steam', 4, true);

  // Play drop sound effect
  sfx.play('drop', 0, volumeLevel);

  // Kill the powerup if it’s not collected
  powerupExpire = game.time.events.add(Phaser.Timer.SECOND * powerupTimeout, function() {
    powerup.destroy();
    sfx.play('bump', 0, volumeLevel);
  });
}

// Apply powerup
function applyPowerup(type) {
  poweredUp = true;
  playerScore += 25;
  updateScore();

  game.time.events.remove(powerupExpire);

  switch (type) {
    case 'coffee':
      runSpeed = 80;

      abilityExpire = game.time.events.add(Phaser.Timer.SECOND * powerupTimeout, function() {
        poweredUp = false;
        runSpeed = 48;
        game.time.events.remove(abilityExpire);
      });

      break;

    case 'disk':
      var startingBrokenPCsLength = brokenPCs.length;

      for(var i = 0; i < startingBrokenPCsLength; i++) {
        fixPC(brokenPCs[0], 'pass', true);
      }

      abilityExpire = game.time.events.add(Phaser.Timer.SECOND * powerupTimeout, function() {
        poweredUp = false;
        game.time.events.remove(abilityExpire);
      });

      break;

    case 'comic':
      playerScore += 225;
      updateScore();

      abilityExpire = game.time.events.add(Phaser.Timer.SECOND * powerupTimeout, function() {
        poweredUp = false;
        game.time.events.remove(abilityExpire);
      });

      break;

    default:
      return null;
  }
}

// Pause/unpause
function handlePause(blur) {
  if(blur && game.paused) {
    game.paused = true;
  } else {
    game.paused = !game.paused;
  }

  if('pauseScreen' in window) {
    // Remove pause screen
    pauseScreen.destroy();
    pause.destroy();
  }

  if(game.paused) {
    // Draw pause screen
    pauseScreen = game.add.graphics(0, 0);
    pauseScreen.beginFill(0x9bbc0f);
    pauseScreen.drawRect(0, 0, game.world.width, game.world.height);
    window.graphics = pauseScreen;

    // Draw pause message
    x = game.world.width / 2;
    y = game.world.height / 2;

    pause = game.add.sprite(x, y, 'pause');
    pause.anchor.x = .5;
    pause.anchor.y = .5;

    pauseText = game.add.bitmapText(1, 0, 'ITBit', 'Pause', 16);
    pauseText.anchor.x = .5;
    pauseText.anchor.y = .5;
    pauseText.tint = 0x0f380f;

    pause.addChild(pauseText);
  }
}

// Game over, man
function gameOver() {
  music.stop();
  sfx.play('die', 0, volumeLevel);
  game.state.start('gameOver');
}

playerScore = 100;
fixedCount = 10;

var gameOverState = {
  create: function(){
    // Set background color
    game.stage.backgroundColor = '#0f380f';

    // Set game over text
    msg = game.add.bitmapText(game.world.width / 2, game.world.height / 2, 'ITBit', 'Game over, man.', 16);
    msg.anchor.x = .5;
    msg.anchor.y = 3.5;

    // Show score
    formattedScore = playerScore + '';

    while(formattedScore.length < 6) {
      formattedScore = '0' + formattedScore;
    }

    score = game.add.bitmapText(game.world.width / 2, game.world.height / 2, 'ITBit', 'Score: ' + formattedScore, 16);
    score.anchor.x = .5;
    score.anchor.y = 2;

    formattedCount = fixedCount + '';

    while(formattedCount.length < 6) {
      formattedCount = '0' + formattedCount;
    }

    fixed = game.add.bitmapText(game.world.width / 2, game.world.height / 2, 'ITBit', 'Fixed: ' + formattedCount, 16);
    fixed.anchor.x = .5;
    fixed.anchor.y = 1;

    // Create a restart button
    btnX = game.world.width / 2 - 34;
    btnY = game.world.height / 2 + 10;

    btn = game.add.sprite(btnX, btnY, 'button');
    btn.inputEnabled = true;

    btnText = game.add.bitmapText(btn.width / 2, btn.height / 2, 'ITBit', 'Play Again', 16);
    btnText.anchor.x = .5;
    btnText.anchor.y = .5;

    btn.addChild(btnText);

    // Restart the game if the button is clicked
    btn.events.onInputDown.add(function(){
      game.state.start('level01', true);
    })
  }
};
// Create game variable
var game = new Phaser.Game(160, 144, Phaser.CANVAS, 'it-worker', null, false, false);

// Set up states
game.state.add('boot', bootState);
game.state.add('load', loadState);
game.state.add('neatfun', neatfunState);
game.state.add('title', titleState);
game.state.add('level01', level01State);
game.state.add('gameOver', gameOverState);

// Start the boot state
game.state.start('boot');